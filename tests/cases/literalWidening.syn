// modified from https://github.com/microsoft/TypeScript/issues/10898

type FAILURE = "FAILURE";
const FAILURE = "FAILURE";

type Result<T> = T | FAILURE;

function doWork<T>(): Result<T> {
  return FAILURE;
}

function isSuccess<T>(result: Result<T>): result is T {
  return !isFailure(result);
}

function isFailure<T>(result: Result<T>): result is FAILURE {
  return result === FAILURE;
}

let result = doWork<number>();

export function f() {
    if (isSuccess(result)) {
        return result;
    }
}


// Syn diverges from TS here
declare function widening<T>(x: T): T;
declare function nonWidening<T extends string | number | symbol>(x: T): T;
declare const cond: boolean

export let x1 = widening('a'); // Both: string
export let x2 = widening(10);  // Both: number
export let x3 = widening(cond ? 'a' : 10); // TS: string | number  Syn: "a" | 10
export let y1 = nonWidening('a'); // TS: "a"  Syn: string
export let y2 = nonWidening(10);  // TS: 10   Syn: number
export let y3 = nonWidening(cond ? 'a' : 10); // Both: "a" | 10


declare function map<T, U>(arr: T[], callbackfn: (value: T) => U): U[];

const langCodes: ("fr" | "en" | "es" | "it" | "nl")[] = []

export const arr = map(langCodes, code => ({ code }))


// const c1 = "hello";  // Widening type "hello"
// let v1 = c1;  // Type string
// const c2 = c1;  // Widening type "hello"
// let v2 = c2;  // Type string
// const c3: "hello" = "hello";  // Type "hello"
// let v3 = c3;  // Type "hello"
// const c4: "hello" = c1;  // Type "hello"
// let v4 = c4;  // Type "hello"

// declare let cond: boolean;
// const c1 = cond ? "foo" : "bar";  // widening "foo" | widening "bar"
// const c2: "foo" | "bar" = c1;  // "foo" | "bar"
// const c3 = cond ? c1 : c2;  // "foo" | "bar"
// const c4 = cond ? c3 : "baz";  // "foo" | "bar" | widening "baz"
// const c5: "foo" | "bar" | "baz" = c4; // "foo" | "bar" | "baz"
// let v1 = c1;  // string
// let v2 = c2;  // "foo" | "bar"
// let v3 = c3;  // "foo" | "bar"
// let v4 = c4;  // string
// let v5 = c5;  // "foo" | "bar" | "baz"