const x: unknown = null

{
    type A = { kind: 'a', data: number }
    type B = { kind: 'b', data: string }
    type C = A | B

    const v: C = { kind: 'b', data: 'hi' }

    if (v is B) {}
}

{
    type A = string[]
    const x: unknown = ['']
    if (x is A) {}
}

{
    const x: unknown = ''
    if (x is number | string) {}
}

{
    const x: unknown = ''
    if (x is 1 | 2) {}
    x is 'a'
}

{
    const x: unknown = ''
    if (x is [number]) {}
    if (x is [number, y: string]) {}
    if (x is [x: { a: string }]) {}
    if (x is any[]) {}
    if (x is [number, ...string[]]) {}
}

{
    const x: unknown = ''
    interface X { x: string }
    interface Y { y: string }
    interface Z extends X, Y { z: string }
    if (x is Z) {}
}

{
    // Classes should emit `instanceof`
    const x: unknown = ''
    class X {}
    if (x is X) {}

    // Should emit `x instanceof X && typeof x.y === 'number'`
    interface X2 extends X {
        y: number
    }
    if (x is X2) {}
}

{
    interface A {
        x: number
        y: number
        z: number
    }
    x is A | A[]
}

{
    type X = 'aa' | 'bb' | 1.1;
    x is `foo${string}bar`
    x is `foo${X}bar`
}

{
    enum X { a, b }
    x is X // FIXME: this should essentially check X.a | X.b
    x is X.a
}