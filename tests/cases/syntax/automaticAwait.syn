/// <reference lib="es2015" />

async function foo() {
    return 1
}

const v = foo() + foo()
if (v != 2) {
    throw `not 2: ${v}`
}

const p = foo() as async
if (!((p as unknown) is Promise<any>)) {
    throw `not a promise?`
}

const n = await p

// A signature is considered async if it can return a Promise _before_ generic substitution
// Async calls within sync functions need an explicit "as async", otherwise it is an error

function sync() {
    const p = foo() as async // OK
    const p2 = foo() // checker error
    foo() as async // OK
    foo() // checker error

    // `await` is still an error inside sync context
    await p
}

async function _async() {
    const v = foo() // OK, inside async context, auto await
    const p = foo() as async // OK
    foo() as async // OK
    foo() // OK, auto await
    sync() as async // checker error, `sync` isn't an async call signature
    await p
    await v // await without a Promise in the type is treated as a possible mistake 

    // redundant awaits are OK, a double await is not emitted and no checker error occurs
    const v2 = await foo()
}

// This function is _not_ considered async, even if the callback is
function wrap<T>(cb: () => T) {
    return cb()
}

function sync2() {
    return wrap(async () => {}) // OK
}

async function _async2() {
    sync2() // automatically awaited
    const p = wrap(async () => {}) // not awaited
}

async function promises() {
    // Promise.all should error if you don't include `as async`
    Promise.all([
        foo() as async, // OK
        foo() as async, // OK
        foo(), // error
    ])
}

// Overloads can restore "async-ness"
declare function wrap2<T>(cb: () => Promise<T>): Promise<T>
declare function wrap2<T>(cb: () => T): T

async function _async3() {
    const v = wrap2(async () => {}) // automatically awaited

    // Promise chains must be awaited
    const v2 = await (foo() as async).then(x => x + 1)
}