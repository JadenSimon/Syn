// CFA should _technically_ treat each defer as potentially executing at any return/throw point 
// but many things can throw in JS, so linear CFA is "good enough" in practice

defer console.log('test')

function assert(a: any, b: any) {
    if (a !== b) {
        throw new Error(`${a} !== ${b}`)
    }
}

// --- blocks ---
let c = 0
{
    c += 1
    defer c -= 1
    assert(c, 1)
}
assert(c, 0)

// --- functions ---
function f1() {
    defer c -= 1
    c += 1
    assert(c, 1)
}

f1()
f1()
assert(c, 0)

function f2() {
    // lifo
    defer c -= 1
    c += 1
    assert(c, 1)
    c += 1
    defer {
        assert(c, 2)
        c -= 1
    }
}

f2()
assert(c, 0)

// --- statements ---

let shouldDecrement = false
function f3() {
    c += 1
    defer if (shouldDecrement) c -= 1
}

f3()
assert(c, 1)
shouldDecrement = true
c -= 1
f3()
assert(c, 0)

function maybe(ret = false) {
    if (!ret) return

    return { v: 1 }
}

{
    c += 1
    defer if (const { v } = maybe(true)) {
        c -= v
    }
    assert(c, 1)
}
assert(c, 0)

async function f4() {
    c += 1
    const p = new Promise<number>(r => setTimeout(() => r(1)))
    defer c -= await p
}

await f4()
assert(c, 0)